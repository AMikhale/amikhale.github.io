# Project Milestone Report
<b>Title:</b> Sudoku Solver Parallelization
  
<b>Completed work:</b> When first beginning to work on the project, we researched existing approaches to Sudoku solvers. In the end, we settled on an approach that would implement various heuristics (equivalent to a human intuition when working on a sudoku puzzle – e.g. if a cell can only be filled with one value, or if it is the only one in its row that contains a certain value, fill it with said value.) When no heuristics can be implemented to a given board, the algorithm results to backtracking – trying one of the available values, taking it as far as it can go, and going back to try a different value if it fails. We decided on an iterative approach versus a recursive one for ease of parallelization using OpenMP. To this end, we currently have a stack onto which we push the sudoku boards being currently considered in order of how full they are.

In terms of the code we have written, we currently have a functional sequential implementation that implements the aforementioned two heuristics and falls back onto backtracking in other cases. (In order to write the implementation, we first had to decide on various conventions and ways to represent the moving parts – the board, the cells, the input files, etc. In hindsight, this makes sense, but we did not anticipate the number of little details that would need to be considered when we first began the project.) We also began to assemble a test suite of boards of varying difficulties, including potential corner cases (e.g. an empty board). We expect the board input to be a valid sudoku board, though this may change in the future. Finally, we have discussed and began to write a parallelized implementation using OpenMP. For now, we intend to allow different threads to all access a global board stack to test different boards and push the results back onto the stack. This requires locking and unlocking the stack, as well as some barriers, to avoid segmentation faults or issues with threads exiting prematurely. We tested out some things, but do not have a functional implementation yet. (We are also considering using distributed work stacks, but figuring out the locks is still necessary for that, so this is the next order of business.)
  
<b>Goals and Deliverables:</b> The goals and deliverables presented in our project proposal largely remain in scope and relevance at this milestone. More specifically, we have successfully built a sequential 16x16 Sudoku solver, implementing the backtracking and the most important, common case heuristic of Single Option Elimination using a board stack to hold pending solutions, that correctly solves 16x16 boards in a reasonable timeframe. The performance of this sequential solver is severely bottlenecked by serialized attempts to fill in the next empty cell, serialized memory accesses for element uniqueness checks, and by the enormous board permutation space growing on the stack that the backtracking algorithm must traverse. This gives us confidence that the sequential solver can be exposed to sufficient parallelism, with much performance gains to be reaped from leveraging OpenMP, and thus currently be on target to achieve the 4x speedup in the parallel solver. At this milestone we are positioned to integrate this parallelism in any combination of these primary critical points: using the board stack as a work queue for concurrent threads each running their own solver (board-level parallelism), checking row/column/box neighbors of a specific cell for value uniqueness concurrently with a blocking assignment (group-level parallelism), and attempting to fill in multiple empty cells in different rows/columns/boxes simultaneously (cell-level parallelism). 

Additionally, we have decided on an input format, and have begun compiling different test boards, and so our test suite for benchmarking will now just be a matter of collecting solved board data and making different files for boards of different proportions of initially empty cells. For testing we will use simple timing code, similar to that which was presented in previous 15-418 assignments, and compile this data into performance graphs for the final report. Finally, for the goals we hope to achieve, we have not looked too much into CUDA for input-level parallelism to simultaneously use multiple boards, but since the CUDA syntax works well with the C++ code we are developing now for the OpenMP solver we are confident this also remains in scope once we have finished the base of the project. Our project also migrates seamlessly over to the Bridges-2 platform.

<i>Goals (Plan to Achieve):</i><br> 
-	Sequential Version of Sudoku Solver that is correct and reasonable, with heuristics for acceleration and backtracking default<br> 
-	Parallel Version of Sudoku Solver using OpenMP for a 4x speedup over the reference sequential solution<br> 
-	Test Suite for benchmarking both sequential and parallel Sudoku Solvers, grouped by difficulty<br> 
-	Final Report analyzing performance characteristics of the two solutions, especially as it pertains to parallelization speedup

<i>Hope to Achieve:</i><br> 
-	Solve 4, 8 boards concurrently with CUDA on NVIDIA GPUs<br> 
-	Analyze performance characteristics on PSC Bridges-2 Regular memory machines

<b>Poster session plan:</b> Since the goal of our project is algorithm optimization and parallel speedup, we plan mostly to present our results with graphs, e.g. speedup against the number of threads. We will also present raw performance values of wall-clock speed with which our algorithm solves 16 x 16 sudoku boards on a different number of threads, as well as the number of steps it performs (equivalent to the total number of boards pushed onto the board stack) averaged across multiple test cases for varying puzzle difficulties. We may also show a demo of our project solving a Sudoku board or two, although we do not plan to implement any elements to make the graphic design stand out, so it may look a bit plain just printing out the solution. 
Preliminary results: We do not currently have any preliminary results in regard to parallel speedup, which will be the main measure of performance for our project. We haven’t written any of the timing code yet, so we cannot accurately report the wall-clock speed with which our current sequential algorithms solves boards (though it greatly depends on the difficulty of the puzzle, ranging from less than a second for simpler ones to about 40 seconds for high difficulty). We plan to repurpose the timing code from the previous assignments to be able to meaningfully assess the performance of our algorithm once we are satisfied with its optimizations. 

  <b>Current issues:</b><br> 
There are a few core issues that are currently in play:<br> 
-	In adding additional heuristics for accelerating the solver, we are not sure if our current implementation of the different uniqueness checks before executing the cell fill actually takes longer than blind backtracking on the short and long runs.
-	We are not yet sure how to use and configure the synchronization primitives required for safely parallelizing the solver.
-	We are not sure yet what the optimal combination of different points of parallelization for performance is, and which ones would make the most sense under the OpenMP format. More specifically it will be very hard to maintain thread safety and solution correctness if we do not carefully blend the different levels of potential parallelism.
The rest currently seems to be mostly a matter of “coding and doing the work.” Additionally, we need to make some timing code and collect more solutions and convert them into test cases.
